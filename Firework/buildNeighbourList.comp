#version 460

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer Positions {
    vec4 positions[];
};

layout(std430, binding = 8) buffer prefixForCountingNearbySSBO {
    atomic_uint neighbourPrefix[];
};

layout(std430, binding = 11) buffer prefixForBinReorderSSBO {
    uint prefixBins[];
};

layout(std430, binding = 12) buffer particlesOrderedByBinSSBO {
    uint reorderedIndices[];
};

layout(std430, binding = 14) buffer neighbourBinsIndicesForBinSSBO {
    uint neighbourBins[];
};

layout(std430, binding = 15) buffer NeighbourListSSBO {
    vec3 neighbourList[];
};

layout(std430, binding = 16) buffer PrefixForOverallNearbyParticles {
    atomic_uint nearbyParticlePrefix[];
};

uniform uvec3 gridResolution;
uniform vec3 gridOrigin;
uniform float gridSpacing;
uniform uint particleNum;
uniform float smoothingLength;

uint neighbourBinIndexCompute(vec4 gridPos)
{
    return uint(gridPos.x) + uint(gridPos.y) * gridResolution.x + uint(gridPos.z) * gridResolution.x * gridResolution.y + uint(gridPos.w) * gridResolution.x * gridResolution.y * gridResolution.z;
}

void main()
{
    uint idx = gl_GlobalInvocationID;
    if (idx >= particleNum) return;

    vec3 pos = particlePositions[idx];

    ivec3 gridPos;
    gridPos.x = int((pos.x - gridOrigin.x) / gridSpacing);
    gridPos.y = int((pos.y - gridOrigin.y) / gridSpacing);
    gridPos.z = int((pos.z - gridOrigin.z) / gridSpacing);

    if (gridPos.x >= 0 && gridPos.x < gridResolution.x &&
        gridPos.y >= 0 && gridPos.y < gridResolution.y &&
        gridPos.z >= 0 && gridPos.z < gridResolution.z) 
    {
        uint prefix = 0;
        uint neighbourNum = 0
        for (uint n = 0; n < 27; n++)
        {
            // getting index of each neighbour
            uint index = neighbourBinIndexCompute(vec4(gridPos.x, gridPos.y, gridPos.z, n));
            if (index != -1)
            { 
                // if neighbour index is valid: 
                uint indexOfNeighbourBin = neighbourBins[index];
                uint start = prefixBins[indexOfNeighbourBin];
                uint end = prefixBins[indexOfNeighbourBin + 1];
                // iterating through each particle inside neighbour n
                for (start; start < end; start++)
                {
                    // if the length between current particle and nearby particle is within smoothing length (1)
                    if (reorderedIndices[start] != idx)
                    {
                        vec3 nearby = positions[reorderedIndices[start]].xyz;
                        float distSqaured = length(nearby - pos);
                        if (distSqaured < smoothingLength *  smoothingLength)
                        {
                            uint neighbourIndex = atomicAdd(nearbyParticlePrefix[0], 1);
                            if (neighbourIndex < particleNum * 32) 
                            {
                                neighbourList[neighbourIndex] = neighbourPos;
                                ++prefix;
                                ++neighbourNum;
                            }
                        }
                    }
                }
            }
        }
        atomicAdd(neighbourPrefix[idx], prefix);
    }
}