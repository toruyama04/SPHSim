#version 460

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer positionsSSBO {
    vec4 positions[];
};

layout(std430, binding = 8) buffer particlesOrderedByBinSSBO {
    uint particlesOrderedByBin[];
};

layout(std430, binding = 7) buffer prefixForBinReorderSSBO {
    uint prefixForBinReorder[];
};

layout(std430, binding = 12) buffer flatNeighboursSSBO {
    uint flatNeighbours[];
};

layout(std430, binding = 10) buffer neighbourListSSBO {
    uint neighbourList[];
};

layout(std430, binding = 6) buffer binIndexForParticleSSBO {
    uint binIndexForParticle[];
};

layout(std430, binding = 11) buffer endIndexBufferSSBO {
    uint endIndex[];
};

layout(std430, binding = 13) buffer neighbourBinOffsetSSBO {
    uint nBinOffset[];
};

uniform float searchRadius;
uniform uint maxNeighboursPerParticle;
uniform uint totalParticles;
uniform uint boundaryParticleNum;


void main() {
    uint idx = gl_GlobalInvocationID.x + boundaryParticleNum;
    uint og = gl_GlobalInvocationID.x;
    if (idx >= totalParticles) return;

    vec3 particlePos = positions[idx].xyz;
    uint binIndex = binIndexForParticle[idx];

    uint neighbourListStart = og * maxNeighboursPerParticle;
    uint neighbourCount = 0;

    float searchRadius2 = searchRadius * searchRadius;

    for (uint binid = nBinOffset[binIndex]; binid < nBinOffset[binIndex + 1]; ++binid) {
        uint neighbourBinIndex = flatNeighbours[binid];

        uint start = prefixForBinReorder[neighbourBinIndex];
        uint end   = prefixForBinReorder[neighbourBinIndex + 1];

        for (uint j = start; j < end; ++j) {
            uint nIndex = particlesOrderedByBin[j];
            vec3 neighbourPos = positions[nIndex].xyz;

            bool notSelf = (nIndex != idx);
            float dist2 = dot(particlePos - neighbourPos, particlePos - neighbourPos);
            bool withinRadius = (dist2 < searchRadius2);
            bool canAdd = (neighbourCount < maxNeighboursPerParticle);

            if (notSelf && withinRadius && canAdd) {
                neighbourList[neighbourListStart + neighbourCount] = nIndex;
                neighbourCount++;
            }

            if (!canAdd) break;
        }

        if (neighbourCount >= maxNeighboursPerParticle) break;
    }

    endIndex[og] = neighbourCount;
}

