#version 450 core

layout(local_size_x = 256) in;


layout(std430, binding = 0) buffer Positions {
    vec4 positions[];
};

layout(std430, binding = 1) buffer Velocities {
    vec4 velocity[];
};

layout(std430, binding = 2) buffer Colours {
    vec4 colours[];
};

layout(std430, binding = 3) buffer RegionPoints {
    vec4 regionPoint[];
};

layout(std430, binding = 4) buffer Origin {
    vec4 origin[];
};

layout(std430, binding = 6) buffer Flags {
    int flags[];
};

layout(binding = 0, offset = 0) uniform atomic_uint aliveCount;


uniform float deltaTime;
uniform vec3  grav;
uniform float minVelocity;
uniform float attractionStrength;
uniform float spiralAttractionStrength;
uniform float spiralness;


void main() {
    uint id = gl_GlobalInvocationID.x;
    origin[id].w -= deltaTime;
    if (origin[id].w < 0.0) {
        flags[id] = 0;
        return;
    }
    flags[id] = 1;
    float lifeR = origin[id].w / colours[id].x;
    vec3 particleDirection = normalize(velocity[id].xyz);

    // Gravity effect
    float gravForce = 1.0 - lifeR;
    velocity[id].xyz += gravForce * deltaTime * grav;

    // Fade out
    colours[id].w = lifeR;

    // spiral attraction towards origin
    vec3 particleToOrigin = origin[id].xyz - positions[id].xyz;
    float distanceToOrigin = max(length(particleToOrigin), 0.001);
    vec3 directionToOrigin = particleToOrigin / distanceToOrigin;
    vec3 tangentialComponent = normalize(cross(directionToOrigin, vec3(0.0, 1.0, 0.0)));
    vec3 spiralForce = spiralAttractionStrength * directionToOrigin + spiralness * tangentialComponent;

    // attraction towards regionPoints
    vec3 toRegionPoint = regionPoint[id].xyz - positions[id].xyz;
    vec3 baseVelocity = normalize(toRegionPoint) * attractionStrength * positions[id].w;
    float attractionFactor = 1.0 - exp(-length(toRegionPoint));
    vec3 regionPointVelocity = baseVelocity * attractionFactor;

    // velocity[id].xyz += (spiralForce + regionPointVelocity) * deltaTime;

    float decayFactor = exp(-0.003);
    velocity[id].xyz *= decayFactor;

    // Update position and lifetime
    positions[id].xyz += velocity[id].xyz * deltaTime;
    atomicCounterIncrement(aliveCount);
}
