#version 460 core

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer Positions {
    vec4 positions[];
};

layout(std430, binding = 1) buffer Velocities {
    vec4 velocity[];
};

layout(std430, binding = 2) buffer Flags {
    int flags[];
};

layout(binding = 0, offset = 0) uniform atomic_uint aliveCount;

uniform float deltaTime;
uniform vec3 grav;
uniform float dampingFactor; // Damping factor for velocity
uniform float noiseScale; // Scale for noise field
uniform float noiseSpeed; // Speed for noise field

// Simple random function
float rand(float n) {
    return fract(sin(n) * 43758.5453);
}

// Noise function
float noise(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);

    float n = dot(i, vec3(1.0, 57.0, 113.0));
    return mix(mix(mix(rand(n + dot(vec3(0.0, 0.0, 0.0), vec3(1.0, 57.0, 113.0))),
                        rand(n + dot(vec3(1.0, 0.0, 0.0), vec3(1.0, 57.0, 113.0))), f.x),
                   mix(rand(n + dot(vec3(0.0, 1.0, 0.0), vec3(1.0, 57.0, 113.0))),
                        rand(n + dot(vec3(1.0, 1.0, 0.0), vec3(1.0, 57.0, 113.0))), f.x), f.y),
              mix(mix(rand(n + dot(vec3(0.0, 0.0, 1.0), vec3(1.0, 57.0, 113.0))),
                        rand(n + dot(vec3(1.0, 0.0, 1.0), vec3(1.0, 57.0, 113.0))), f.x),
                   mix(rand(n + dot(vec3(0.0, 1.0, 1.0), vec3(1.0, 57.0, 113.0))),
                        rand(n + dot(vec3(1.0, 1.0, 1.0), vec3(1.0, 57.0, 113.0))), f.x), f.y), f.z);
}

// Curl noise function
vec3 curlNoise(vec3 p) {
    const float e = 0.1;
    vec3 dx = vec3(e, 0.0, 0.0);
    vec3 dy = vec3(0.0, e, 0.0);
    vec3 dz = vec3(0.0, 0.0, e);

    float x = noise(p + dy) - noise(p - dy) - noise(p + dz) + noise(p - dz);
    float y = noise(p + dz) - noise(p - dz) - noise(p + dx) + noise(p - dx);
    float z = noise(p + dx) - noise(p - dx) - noise(p + dy) + noise(p - dy);

    return vec3(x, y, z) / (2.0 * e);
}

void main() {
    uint id = gl_GlobalInvocationID.x;

    // Apply gravity
    velocity[id].xyz += grav * deltaTime;

    // Apply curl noise for fluid-like motion
    vec3 noisePos = positions[id].xyz * noiseScale + vec3(0.0, noiseSpeed * deltaTime, 0.0);
    vec3 curl = curlNoise(noisePos);
    velocity[id].xyz += curl * deltaTime;

    // Apply damping to velocity
    velocity[id].xyz *= dampingFactor;

    // Update position
    positions[id].xyz += velocity[id].xyz * deltaTime;

    // Update lifetime
    positions[id].w -= deltaTime;
    if (positions[id].w < 0.0) {
        positions[id].w = -1.0;
        flags[id] = 0;
        return;
    }
    flags[id] = 1;

    atomicCounterIncrement(aliveCount);
}

