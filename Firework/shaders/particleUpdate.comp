#version 460 core

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer Positions {
    vec4 positions[];
};

layout(std430, binding = 1) buffer Velocities {
    vec4 velocity[];
};

layout(std430, binding = 2) buffer Fluid {
    vec4 fluids[];
};

layout(std430, binding = 3) buffer Flags {
    int flags[];
};

layout(binding = 0, offset = 0) uniform atomic_uint aliveCount;

uniform float deltaTime;
uniform vec3 grav;
uniform float smoothing_length;
uniform float viscosity_coefficient;
uniform uint preAliveCount;
uniform float restDensity = 1000.0;
const float gasConstant = 2000.0;
float kernelRadius2 = smoothing_length * smoothing_length;

// calculating the gradient of the influence of neighbouring particles
float poly6Kernel(float r2) {
    float h2 = kernelRadius2;
    return (315.0 / (64.0 * 3.141592 * pow(h2, 3))) * pow(h2 - r2, 3);
}

vec3 spikyKernelGradient(vec3 r, float r2) {
    float h = smoothing_length;
    return -45.0 / (3.141592 * pow(h, 6)) * pow(h - sqrt(r2), 2) * normalize(r);
}

void main() {
    uint id = gl_GlobalInvocationID.x;

    // Compute density
    fluids[id].x = 0.0;
    for (uint j = 0; j < preAliveCount; ++j) {
        vec3 r = positions[j].xyz - positions[id].xyz;
        float r2 = dot(r, r);
        if (r2 < kernelRadius2) {
            fluids[id].x += fluids[id].z * poly6Kernel(r2);
        }
    }
    fluids[id].y = gasConstant * (fluids[id].x - restDensity);

    // Compute forces
    vec3 pressureForce = vec3(0.0);
    vec3 viscosityForce = vec3(0.0);
    for (uint j = 0; j < preAliveCount; ++j) {
        if (j != id) {
            vec3 r = positions[j].xyz - positions[id].xyz;
            float r2 = dot(r, r);
            if (r2 < kernelRadius2) {
                // Pressure force
                pressureForce += -fluids[j].z * (fluids[id].y + fluids[j].y) / (2.0 * fluids[j].x) * spikyKernelGradient(r, r2);

                // Viscosity force
                viscosityForce += viscosity_coefficient * fluids[j].z * (velocity[j].xyz - velocity[id].xyz) / fluids[j].x * poly6Kernel(r2);
            }
        }
    }

    // Update velocity and position
    vec3 acceleration = (pressureForce + viscosityForce) / fluids[id].x;
    velocity[id].xyz += acceleration * deltaTime;

    // Gravity effect
    // velocity[id].xyz += deltaTime * grav * 0.2;

    // float decayFactor = exp(-0.003);
    // velocity[id].xyz *= decayFactor;

	positions[id].w -= deltaTime;
    if (positions[id].w < 0.0) {
        positions[id].w = -1.0;
        flags[id] = 0;
        return;
    }
    flags[id] = 1;

    positions[id].xyz += velocity[id].xyz * deltaTime;
    atomicCounterIncrement(aliveCount);
}



