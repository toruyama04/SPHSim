#version 460

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer ParticlePositions {
    vec4 positions[];
};

layout(std430, binding = 4) buffer GridData {
    uint gridStartIndices[];
    uint particleGridIndices[];
};

layout(std430, binding = 5) buffer NeighborData {
    uint neighborList[];
};

uniform float cellSize;
uniform float searchRadius;
uniform ivec3 gridResolution;
uniform uint numParticles;
uniform uint maxNeighbors;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= numParticles) return;

    vec3 position = positions[id].xyz;
    ivec3 gridIndex = ivec3(floor(position / cellSize));

    uint neighborCount = 0;
    uint offset = gridResolution.x * gridResolution.y * gridResolution.z;

    // Iterate over surrounding cells
    for (int z = -1; z <= 1; ++z) {
        for (int y = -1; y <= 1; ++y) {
            for (int x = -1; x <= 1; ++x) {
                ivec3 neighborGridIndex = gridIndex + ivec3(x, y, z);
                uint neighborCellID = (neighborGridIndex.x * 73856093) ^ (neighborGridIndex.y * 19349663) ^ (neighborGridIndex.z * 83492791);
                neighborCellID %= gridResolution.x * gridResolution.y * gridResolution.z;

                uint start = gridStartIndices[neighborCellID];
                uint end = gridStartIndices[neighborCellID + 1];

                // Check each particle in the cell
                for (uint i = start; i < end; ++i) {
                    uint neighborId = particleGridIndices[offset + i];
                    vec3 neighborPosition = positions[neighborId].xyz;
                    if (distance(position, neighborPosition) < searchRadius) {
                        neighborList[id * maxNeighbors + neighborCount++] = neighborId;
                        if (neighborCount >= maxNeighbors) break;
                    }
                }
            }
        }
    }
}

